# Практична робота №3
Темою практичної роботи - дослідження обмежень ресурсів у середовищі Docker
## Завдання 1
### Умова
Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку:
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3001
$ ulimit -n 2000
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000

Як наступне вправу, повторіть перераховані команди з root-правами.

### Рішення
На скриншотах нижче можна побачити введені мною команди спочатку в режимі звичайного користувача, а далі з root-правами відповідно.

![image](https://github.com/user-attachments/assets/06becf66-48ad-416d-90c2-e802111d17ca)

![image](https://github.com/user-attachments/assets/770cfeee-bdc1-4156-8e4b-8d2d4845a021)

Можемо побачити, що суттєвої різниці немає : те, що не може робити звичайний користувач, так само заборонено і для root-користувача. 
Це, скоріше за все, відбувається через те, що в умові задачі є помилка, і замість root малося на увазі privilege. Тоді було б помітно різницю в дозволах.

## Завдання 2
### Умова
У Docker-контейнері встановіть утиліту perf(1). Поекспериментуйте з досягненням процесом встановленого ліміту.

### Рішення
У ході виконання я зіткнулася з проблемою, яку так і не змогла вирішити, і жоден ШІ мені не допоміг. Проте, це сталося коли я намагалася попрацювати з perf вдруге, бо коли я робила це перший раз, я забула зробити скріншоти.. А сама помилка на скріншоті нижче.

![image](https://github.com/user-attachments/assets/7498d298-bbe8-4e29-9008-bb5c9b4f3aa3)

Відновивши свої спогади про дебют використання мною утиліти perf та додатково проаналізувавши теоретичну інформацію, я можу сказати, що утиліта perf - це як супер-інструмент для розслідування того, що відбувається всередині програм, коли вони працюють на Unix-подібних ОС. Вона може показувати, які функції займають найбільше часу, де відбуваються затримки, скільки ресурсів використовується і тд. У запропонованому експерименті, коли ми будемо намагатися змусити процес досягти встановленого ліміту (наприклад, ліміту на використання пам'яті чи процесорного часу), perf допоможе побачити, як саме процес поводиться наближаючись до цього ліміту (чи сповільнюється він, чи виникають якісь помилки, і взагалі, як система реагує на ці обмеження).

## Завдання 3
### Умова
Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.

### Рішення
Для виконання цього завдання я написала [код](https://github.com/AnastasiiaVdovina/Practice3/blob/main/task3.c), яккий, відповідно до умови задачі, імітує кидання шестигранного кубика. Подібну програму нам вже доводилося писати в ході вивчення курсу "Основи програмування - 1". 
Я встановила обмеження на розмір файлу в 1 Кб, і поекспериментувавши, отримаємо такі результати:

![image](https://github.com/user-attachments/assets/12b7a1d3-63f8-4f4f-9d7c-bf2aa0ac4ae7)

![image](https://github.com/user-attachments/assets/44b00ade-601b-4b2c-80b7-c52b92fc4369)

Бачимо, що на початку, програма дозволяє нам записати у файл 4 значення. Після цього, я записала ще 500, а далі спробувала 1000, і ми досягли ліміту файлу.
Як в цьому коді працює обробка перевищення встановленого ліміту?
Сама перевірка перевищення ліміту розміру файлу відбувається в циклі перед кожним записом результату кидка кубика.
Функція get_file_size(FILE_NAME) отримує поточний розмір файлу diceroll_results.txt за допомогою stat().
Перед кожним записом у файл (fprintf(file, "%d\n", result)) виконується перевірка if(get_file_size(FILE_NAME) >= MAX_FILE_SIZE).
Якщо розмір файлу досягає або перевищує 1 KB (MAX_FILE_SIZE), виводиться повідомлення "File size limit reached", і цикл припиняється (break).
Якщо ліміт не перевищено, значення кидка записується у файл і виводиться на екран.

## Завдання 4
### Умова
Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.

### Рішення
Принцим роботи [програми](https://github.com/AnastasiiaVdovina/Practice3/blob/main/task4.c) схожий до поперденьої, але обмеження вже тут на max CPU time. Оскільки я поставила його в 1 секунду, то програма не перевищує ліміт, і працює коректно, як на скріншоті нижче.

![image](https://github.com/user-attachments/assets/e392d813-8bb3-4f3b-a651-936a900eeef0)

Якщо встановити ліміт менше, це все одно працює. Але якщо додати до програми якийсь безкінечний цикл(оскільки сама програма досить швидка і проста), то нам вдасться досягти перевищення ліміту.

## Завдання 5
### Умова
Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів.
Програма має:
перевіряти, чи передано два аргументи, інакше виводити "Program need two arguments";
перевіряти доступність першого файлу для читання, інакше виводити "Cannot open file .... for reading";
перевіряти доступність другого файлу для запису, інакше виводити "Cannot open file .... for writing";
обробляти ситуацію перевищення обмеження на розмір файлу.

### Рішення
Я написала [код](https://github.com/AnastasiiaVdovina/Practice3/blob/main/task5.c), що чітко відповідає вимогам завдання. Схожу задачу ми вирішували теж на курсі "ОП-1" та "ОП-2", коли вчилися працювати з файлами, але , очевидно, що ми тоді ще не бавились з лімітами. 
Тож, якщо ми порушимо умову №1 та запустимо програму без агрументів, побачимо наступне:

![image](https://github.com/user-attachments/assets/11dd0728-a70f-46a0-b85a-42fa91690b5f)

А якщо зробимо все правильно, то:

![image](https://github.com/user-attachments/assets/970e58b8-e293-4a47-81e7-26bbdecaeac3)

Щоб перевірити, чи коректно програма все скопіювала, відкриємо вміст файлів, та порівняємо їх:

![image](https://github.com/user-attachments/assets/89cabd71-455e-4bb9-a121-417bbfa0f974)

![image](https://github.com/user-attachments/assets/6b040dff-dec2-4a03-ada2-9b145225c060)

Отже, все спрацювало коректно, всі обробки присутні.

## Завдання 6
### Умова
Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.

### Рішення
Було написано демонстаційний варіант [програми](https://github.com/AnastasiiaVdovina/Practice3/blob/main/task6.c). Ця програма працює наступним чином:
Вона отримує поточні обмеження стека (RLIMIT_STACK) і виводить їх. Потім викликається рекурсивна функція, яка створює локальний масив stack_array (1 KB) і збільшує глибину рекурсії, викликаючи сама себе. Оскільки кожен виклик споживає додаткову пам’ять на стеку, при досягненні rlim_cur (м’якого обмеження) програма викличе переповнення стека (stack overflow) і аварійно завершиться (Segmentation fault). Результат роботи функції показано на скриншоті нижче.

![image](https://github.com/user-attachments/assets/3d0b91aa-6cf6-43cb-8995-ec32863e112c)

## Завдання 7(Індивідуальне завдання)
### Умова
Написати програму, яка створює багато потоків та перевірити вплив ulimit -u.

### Рішення
Я, відповідно до умови, зробила багатопоточну [програму](https://github.com/AnastasiiaVdovina/Practice3/blob/main/ind_task.c). Вона просто створює багато потоків і не несе ніякого практичного функціоналу, тобто вона демонстраційна. 
Через ulimit -u я встановила ліміт на кількість потоків в 2000. Але як ми бачимо на скріні нижче, прорама створила набагато менше, і зупинилась.

![image](https://github.com/user-attachments/assets/c7b7fdea-d525-4f7a-85a3-c20d9226a4fb)

Чому так відбулося? Мене теж цікавило це питання.
У FreeBSD, як виявилось "ulimit -u" обмежує максимальну кількість процесів для користувача, а не потоків. Хоч і потоки теж вважаються процесами, проте конкретно для них існують інши утиліти для встановлення обмежень:
- Обмеження стека (ulimit -s) (визначає, скільки потоків можна створити в межах доступної пам’яті)
- Обмеження ядра (sysctl) (керують максимальною кількістю потоків у системі та на процес)
- Обмеження дескрипторів файлів (ulimit -n)







